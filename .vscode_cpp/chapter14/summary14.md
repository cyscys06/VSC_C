# C++ 코드의 재활용

## 객체 멤버를 가지는 클래스

### valarray 클래스
- 수치 값들(비슷한 속성을 가진 클래스들)을 다루는 클래스
- 배열 인덱스의 총합, 최대값, 최소값 등을 간단히 구할 수 있는 클래스
- 형식: valarray<int> q_value; // int형 배열을 valarray라는 클래스의 객체로 선언한 것
- 객체 선언 방식에 따라 디폴트 크기(0)를 할당하거나, 크기를 지정해주거나, 배열의 모든 인덱스에 동일한 값을 넣어주거나, 임의 배열의 n번째 인덱스까지 복사하여 초기화하는 등의 선언이 가능하다
- 이때 []연산자 오버로딩은 배열의 인덱스에 대한 접근을 제공, size()는 원소의 개수를 리턴, sum()은 원소의 총합을 리턴, max()와 min()은 각각 최대값, 최소값을 리턴한다.
- 임의 클래스는 valarray클래스를 멤버로 하는 멤버 값등을 가질 수 있다. 이때 valarray와 임의 클래스의 관계는 has-a관계이다.
- 객체 안에 정의된 객체(string, valarray 등)은 연결 연산자(.이나 -> 등)으로 사용 범위 내에서 접근 가능하다
- 파생 객체의 기초 클래스 부분을 초기화할때 멤버 초기자 리스트 사용, 객체의 이름을 넣고 초기화할때는 기초 클래스의 생성자가 호출됐었음음
- 멤버 초기자 리스트 문법에서 클래스의 멤버 이름을 넣으면 그 멤버가 속한 클래스의 생성자를 호출함. 예를들어 string의 멤버를 이름을 넣으면 string 클래의 생성자가 호출된다(사실 의미는 같음).
- 멤버 초기자 리스트는 객체가 생성될때 객체의 멤버들도 미리 같이 생성하겠다는 의미임. 이런 멤버 초기자 리스트가 없으면 디폴트 생성자가 호출됨.
- 임의 클래스 안에서 임의 객체의 메서드 호출:
1. 임의 클래스의 메서드 호출
2. 그 메서드가 클래스에 속한 임의 객체 사용
3. 그 객체의 메서드가 호출

- <<연산자 오버로딩은 프렌드 함수여야한다(하나는 ostream 매개변수, 하나는 출력할 매개변수의 자료형으로 총 두개를 강제로 받아야 하기 때문에 프렌드로 선언한다).
- valarray도 마찬가지로 출력을 위한 <<연산자 오버로딩을 사용자가 정의하여 사용 가능하다(valarray 클래스를 위한 헬퍼 함수).


## private 상속
- has-a 관계 구현 제 2번째
- 기초 클래스의 public이나 protected범위 멤버들이 파생 클래스의 private멤버가 된다.
- 기존 is-a관계에서는 public상속 방식(기초 클래스의 public이 파생 클래스의 public의 메서드가 되는 것)이었음. 하지만 has-a관계는 상속되는 관계가 아니므로(임의 클래스가 다른 클래스의 멤버가 되는 것이므로) private멤버로 상속된다.
- 컨테인먼트: 객체를 이름을 가진 채로 다른 클래스에 넣는 상속
- private 상속: 객체를 이름이 없는 상태로 다른 클래스에 넣는 상속
- 컨테인먼트, private 상속에 의해 추가된 객체 모두 종속 객체로 부른다.
- 둘은 동일한 기능이지만 private 상속은 인터페이스(간단하게 추상화 기초 클래스라고 생각하면 됨. 파생 클래스에 대해 메서드들을 제공하는 클래스임)는 없는 상속이다.
- 다중 상속: 기초 클래스가 2개 이상이고 파생 클래스가 그 클래스들을 상속받는 경우
- private 상속은 이름이 없는 상태로 객체가 상속되므로 대신 클래스 이름을 써서 생성자를 식별한다.
- 즉, 컨테인먼트라면 name.method()형태로 메서드를 호출한다면, private 상속은 Class::method()형태로 메서드를 호출한다(private 상속에서 객체의 메서드는 이름이 없으므로 클래스의 메서드 함수를 호출하는 방식).
- 임의 클래스의 name에 대한 객체는 string형 객체이다. -> 객체가 이름을 가지지 않으므로 그 임의 클래스 객체에 대한 생성자의 반환형을 string으로 변환한다. 이는 상속된 string 클래스 객체가 된다.  
- 프렌드 함수여서 클래스의 멤버 함수를 호출할 수 없는 경우라면 프렌드 함수의 전달인자에 명시적으로 데이터형 변환을 해서 사용 가능하다. ex) os << (const string &) stu -> 전달인자인 stu는 명시적 데이터 변환을 하였으므로 string형 객체를 참조로 받는다.

### protected 상속
- 기초 클래스의 public, protected멤버가 파생 클래스의 protected멤버가 되는 상속
- 1세대 클래스: 기초 클래스 2세대 클래스: 파생 클래스 3세대 클래스: 파생 클래스의 파생 클래스
- protected의 특성(파생 클래스에 대해서는 public이지만 관계 없는 아예 남인 클래스에서는 private으로 작용) 때문에 protected 상속의 장점은 3세대 클래스가 2세대 클래스의 멤버들을 사용 가능하다(private 상속의 2세대 클래스라면 다른 클래스에서 접근 불가하기 때문에 3세대 클래스에서 접근 불가할 것이다).

### using 사용하여 접근 다시 정의
- using 선언으로 파생 클래스에서 사용할 특정 기초 클래스 멤버를 지정 가능하다.
- 선언 후에 그 멤버들은 public 메서드인것처럼 마음대로 사용 가능하다.
- 형식: using std::valarray<double>::max; // valarray객체의 max메서드를 선언 -> 멤버 이름(max)만 사용하여 선언한다.
- const를 붙일수도 있고 안붙일수도 있다.
- 이 선언은 상속에만 적용되며 컨테인먼트에는 적용되지 않는다.
- 파생 클래스에 기초 클래스 메서드들을 재정의하는것도 가능하다(구식).

## 다중 상속
- 다중 상속은 is-a관계로 나타내야 한다.
- 이때 하나의 파생 클래스가 동일한 성분을 갖는 두 클래스를 파생해서 두개의 같은 상속 멤버를 가질수도 있으므로(포인터에서 지시할 주소가 2개가 돼서 에러 발생할 수 있음), 각각 명시적 데이터형 변환을 사용해서 구분을 해야 한다.
- 하지만 근본적인 문제는 같은 성분의 멤버를 2개 가질 필요가 없는 것이다. 이는 가상 기초 클래스로 해결 가능하다.
- 가상 기초 클래스: 하나의 공통 조상을 가지는 여러 개의 기초 클래스로부터 공통 조상의 유일 객체를 상속하는 방식으로 객체를 파생시키는 것
- 가상 함수: 기초 클래스에서 선언되고, 파생 클래스에서 재정의될 수 있으며, 실행 시점에 어떤 함수가 호출될지 결정되는 함수(즉, 실행 전까지는 어떤 함수를 호출하는지 정해지지 않은 함수).
- virtual 키워드: 함수를 가상함수로 만드는 매개체(키워드). 어떤 함수가 여러개의 클래스에서 정의된 상태(각자 다른 매개변수, 다른 몸체를 가질때)에서 그 함수를 사용하게 되면 어떤 클래스의 함수를 사용하는 것인지 정확히 알 수 없음. 이를 가상함수로 만듦으로써 프로그램 실행 전에는 어떤 클래스의 함수를 사용할지 모르다가 나중에 어떤 클래스의 함수를 사용할 것인지 고르게 하는것임. 이는 값과 참조의 차이와도 비슷한 개념임. 참조는 어떤 변수의 값을 실제로 가져와서 함수 매개변수로 사용하는거고, 값으로 전달하는 거는 어떤 변수에 할당된 값에 대한 복사본을 만들어서 함수 안에 넣는거임. 이때 값은 1세대 클래스를 일반적인 방법으로 상속받은 2세대 클래스들이라 볼 수 있고, 참조는 virtual 키워드를 사용해서 2세대 클래스들이 1세대 클래스를 가상으로 상속하도록 하는거랑 상당히 유사하다고 볼 수 있음. 어떤 함수가 있고, 그 매개변수는 참조값을 받음. 이때 전달인자는 같은 자료형이어도 어떤 변수의 참조값이 올지 알수 없음(이를 의미하는 것이 virtual 키워드임).
- 1세대 클래스 A가 있고, 2세대 클래스 B, C가 있고, 3세대 클래스 D가 있음. 여기서 B, C가 A를 단순 상속받게 되면 A의 멤버들이 B, C에 둘다 상속(복사본 형태로 하여금)하게 되고, 중복이 발생함. 여기까진 문제가 없으나 D에서 B, C를 둘다 상속받는데 이름이 같은 두 멤버를 동시에 상속받으면 문제가 생김. 이를 방지하기 위해 virtual을 사용해서 B, C가 A를 상속받고 있는건 맞지만 실제로 상속하는게 아니라는거임. 그래서 가상으로 상속하고 있다고 표현하는거임.