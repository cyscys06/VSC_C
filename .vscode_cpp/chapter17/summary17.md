## peek()
- peek()함수는 get()함수와 달리 버퍼에 문자를 계속 남겨놓음(get()은 글자를 읽고 버퍼에서 없앰)
  
## 파일 입출력
- fout: 사용자가 키보드로 입력한 값을 파일을 통해 출력 가능
- fin: 파일 속 값을 모니터에 출력 가능
- fstream 헤더파일: fout을 쓸수 있는 ofstream이나 fin을 쓸수 있는 ifstream 두개를 쓸수있게 해주는 헤더파일

## 메서드의 멤버함수로의 사용과 매개변수 사용으로의 차이점
- ex) getline()
- getline()을 임의 객체의 멤버 함수로 사용하는 경우: char형으로 받음(한글자씩)
- getline()이 임의 객체를 매개 변수로 사용하는 경우: string형으로 받음(통째로)

## 이터레이터 사용 이유
- 이터레이터는 보통 컨테이너 자료구조에 자주 사용함
- 배열과 달리 컨테이너의 종류(벡터, 세트, 리스트 등등)에는 원소 순서가 있는것도, 없는것도 있음
- 그래서 어떤 컨테이너에는 순차적으로 접근이 가능하지만 어떤 컨테이너는 순서가 없어서 순차적 접근이 불가능함
- 그런데 프로그래밍을 하다보면 필연적으로 다양한 컨테이너를 사용하게 됨
- 다양한 종류의 데이터를 받기 때문에 그에 알맞게, 적절히 사용 가능한 컨테이너를 각각 고르게 됨
- 그런데 위에서 언급한 이유 때문에 사용자는 각각의 컨테이너에 서로 다른 접근법을 사용할 수 밖에 없음(컨테이너 종류마다 접근 방법이 다르기 때문이다)
- 이때 이터레이터를 사용하면 모든 컨테이너에 대해 동일한 접근 방법(순차적 접근)을 사용하기 때문에, 서로 다른 컨테이너라도 이터레이터를 사용하면 동일한 방법을 사용 가능함
- 이터레이터가 없었다면 컨테이너별로 서로 다른 접근법을 사용하면서 데이터를 관리했을 것이다(이는 비효율적이다)
- 이를 이터레이터를 사용함(여러 컨테이너에 대해 동일한 접근)으로써 여러가지 접근법을 하나로 줄이게 됐고, 효율성이 올라가게됨