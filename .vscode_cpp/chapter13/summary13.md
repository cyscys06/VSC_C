## 클래스 상속 

### 기초 클래스, 파생 클래스
- 기초 클래스는 파생 클래스가 상속받을 오리지널 클래스를 의미하고, 파생 클래스는 기초 클래스로부터 상속을 받을 새로운 클래스를 의미한다.
- C 스타일의 string은 const char *형으로 문자열을 받고, string객체형은 const string &형으로 문자열을 받는다.
- 파생된 클래스형의 객체 안에는 기초 클래스가 갖고 있던 데이터 멤버들이 저장된다(구현을 상속받음). 또한 기초 클래스의 메서드를 사용할 수 있다(인터페이스를 상속받음).
- 상속받은 클래스라도 private멤버에는 접근이 불가능하다(상속하는 클래스 안에서 private이므로 상속을 받아서 그 멤버를 가지더라도 직접 접근은 불가). 이는 상속받은 클래스의 public 메서드를 사용해서 간접적으로 private에 접근 가능하다.
- 파생 클래스에서 객체를 생성하면, 기초 클래스에서 먼저 객체가 생성된다. 즉, 프로그램이 파생 클래스 안으로 들어가려면 먼저 기초 클래스에서 객체를 생성해야 한다는 말이다.
- 객체의 생성과 파괴는 반대로 일어난다. 즉, 객체를 생성할때 생성자를 먼저 호출하고 그다음 몸체를 실행했다면, 객체를 파괴할때는 몸체를 먼저 실행해서 객체를 파괴한 뒤에, 파괴자 함수를 호출한다.
#### 파생된 클래스에서 가능한 것: 
  1. 새로운 기능 추가가 가능하다.
  2. 클래스가 나타내고 있던 데이터에 다른 것을 더 추가 가능하다.
  3. 메서드 동작 방식을 변경할 수 있다.

#### 파생된 클래스에 추가 가능한 것:
- 파생된 클래스에서는 자기 자신에 대한 생성자를 별도로 요구한다.
- 필요한 만큼 데이터 멤버 및 멤버 함수를 더 추가 가능하다.

### 다시 사용되는 멤버 초기자 리스트 문법
- 파생 클래스에 객체를 생성하기 전에 미리 기초 클래스에 객체를 생성하기 위해 사용한다.
- 파생 클래스 생성자에서 매개변수로 값을 받으면 먼저 자신의 생성자에 매개변수를 대입하고, 그 후 멤버 초기자 리스트로 만들어진 기초 클래스 생성자에게 매개변수를 전달한다(파생 클래스 생성자 자기가 먼저 받고, 그다음 기초 클래스 생성자에게 매개변수 넘긴다는뜻)
- 멤버 초기자 리스트로 기초 클래스 생성자를 만들지 않아도 어차피 기초 클래스 생성자가 먼저 객체를 만든다는 사실은 변하지 않기 때문에, 기초 클래스의 디폴트 생성자가 만들어져 객체를 먼저 생성한다. 따라서 사용자는 자신의 선택에 따라 명시적(사용자 정의) 또는 암시적(디폴트)으로 기초 클래스 생성자를 사용하게 된다.
- 파생 클래스를 위한 멤버 초기자 리스트 문법도 물론 사용 가능하다. 

#### 기초 클래스와 파생 클래스가 정보를 전달받는 방식 정리
1. 기초 클래스의 객체가 먼저 생성된다(반드시).
2. 기초 클래스의 멤버 초기자 리스트로 인해, 파생 클래스가 데이터 정보를 기초 클래스 생성자에게 제공한다.
3. 파생 클래스에서 새로 추가된 데이터 멤버들을 초기화한다.

### 기초 클래스와 파생 클래스 관계
- 기초 클래스에서 선언한 포인터 및 참조가 파생 클래스의 객체를 가리킬 수 있다.
- 하지만 그 포인터나 참조는 기초 클래스 메서드만 호출 가능하다. 즉 파생 클래스의 메서드는 호출 불가하다.
- 반대로 파생 클래스의 포인터 및 참조가 기초 클래스의 주소, 객체를 가리키는 것은 불가능하다(기초에서 파생으로만 접근 가능하다는 뜻).
- 기초 클래스의 참조와 포인터는 기초 클래스와 파생 클래스 둘 다에서 사용 가능하다.
- 기초 클래스 객체를 파생 클래스 객체로 초기화하는 경우: 암시적 복사 생성자
- 파생 클래스 객체를 기초 클래스 객체로 초기화하는 경우: 암시적 오버로딩 대입 연산자 
### 상속: is-a 관계
- 상속의 3가지 종류: public, private, protected

### 가상 메서드
- 생성자는 가상 함수가 될 수 없다.
- 파괴자는 가급적 가상으로 선언해야 한다(파괴자가 필요 없는 상황이라도).
- 정적결합이면 포인터 or 참조 자제의 자료형을, 동적결합이면 포인터 또는 참조가 지시하는 객체의 자료형에 따라 가상 함수를 호출한다.
- 프렌드 함수는 가상 함수가 될 수 없다. 프렌드는 클래스 멤버가 아니기 때문이다.
- 파생 클래스에서 함수를 다시 정의하지 않으면 기초 클래스 버전의 함수를 사용한다.
- 상속된 메서드(멤버 함수)를 파생 클래스에서 같은 이름으로 다시 정의할때 그 합수는 오버로딩된 것이 아니며, 새롭게 정의한 함수는 기초 클래스에 존재하던 함수를 가린다(같은 이름을 가진 모든 기초 클래스 메서드를 가린다).
- 따라서 기초 클래스 메서드를 파생 클래스에서 사용하려고(예를들면 파생 클래스에만 존재하는 멤버를 함수로 받고싶을때) 재정의하는 경우에는 기초 클래스 메서드와 리턴형, 이름, 매개변수 전부 같아야 한다.
- 공변: 리턴형이 기초 클래스 포인터나 참조일때 이가 파생 클래스 포인터나 참조로 대체 가능함을 말한다. 이는 리턴형만 예외로 가능하다.
- 기초 클래스에서 특정 함수를 오버로딩 한 것이라면, 파생 클래스에서도 그 오버로딩된 함수들을 전부 일일히 재정의 해줘야 한다.

### PROTECTED 범위
- private과 비슷하다. 접근하려면 public의 메서드를 통해 간접적으로 접근해야 한다.
- private과의 차이는 파생 클래스에 있다. 파생 클래스의 멤버들은 기초 클래스의 protected 멤버들에 직접 접근이 가능하다. 이와 달리 private멤버들에는 접근이 불가능하다.

### 추상화 기초 클래스
- 여러 개의 클래스로부터 공통적인 사항만을 모아 넣어놓은 클래스. 여러 개의 클래스들이 서로 파생되기엔 겹치지 않는(즉 자기자신 클래스에서만 쓰는) 멤버들을 가지고 있을때 겹치는 멤버들만 따로 빼서 추상화 기초 클래스에 넣어놓고, 여러 개의 클래스들은 전부 기초 클래스에서 파생된 클래스로 선언하는 방식이다.
- 순수 가상 함수: 추상화 기초 클래스에서 선언된, 함수 선언 뒤에 =0; 을 가지는 함수이다.
- 클래스 선언에 순수 가상 함수가 들어있으면, 그 클래스는 객체를 생성할 수 없다. 순수 가상 함수를 갖고 있는 클래스는 기초 클래스의 역할만을 수행하기 위한 것으로 인식하기 때문이다. 
- 어떤 클래스가 추상화 기초 클래스가 되기 위해서는 적어도 하나의 순수 가상 함수가 필요하다. =0; 이라는 코드가 가상 함수를 순수 가상 함수로 만든다. 
- 순수 가상 함수로 만들었더라도 정의는 가능하다. 
- 추상화 기초 클래스에서 파생된 클래스들은 자기 자신의 객체는 생성할 수 있지만, 추상화 기초 클래스의 객체는 생성할 수 없다.
- 파생 클래스들의 객체는 전부 기초 클래스에서 나온 것일 수 있으므로(기초 클래스에 있던 멤버면) 포인터 배열을 통해 추상화 기초 클래스에서 그 객체들을 관리 가능하다.

### 상속과 동적 메모리 대입
- 기초 클래스에서 동적 메모리를 사용하고 대입 연산자와 복사 생성자를 정의한다고 가정
- 파생 클래스가 동적 메모리를 사용하지 않을때는 명시적 파괴자, 대입 연산자, 복사 생성자 등을 재정의할 필요 X: 파생 클래스를 위한 디폴트 파괴자의 경우 기초 클래스의 파괴자도 같이 호출하기 때문에 이것만으로 충분하다. 또한 어차피 new로 동적 메모리를 파생 클래스에 새로 할당한게 아니라면 기초 클래스와 같은 멤버를 공유할 것이기 때문에, 멤버별 복사를 하는 복사 생성자면 충분하다. 이는 대입 연산자도 마찬가지이다.
- 파생 클래스가 동적 메모리를 사용할때는 파생 클래스를 위한 명시적 파괴자, 대입 연산자, 복사 생성자 등을 정의해 줘야 한다. 
