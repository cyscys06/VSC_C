지역 변수 캡쳐 과정
1. 지역 클래스의 객체 생성할 때 지역 클래스가 접근하는 지역 변수를 컴파일러에서 확인
2. 지역 클래스가 사용하는 지역 변수가 있으면 복사함(매개변수도 지역변수이므로 복사함)
3. 복사한 지역 변수를 지역 클래스 객체에 포함한다
4. 복사한 지역 변수를 객체를 통해 접근 가능

-> 원래 지역변수는 그 변수가 속한 메서드가 종료되면 같이 사라지고, 
클래스는 지역변수보다 생명주기가 길어서 나중엔 클래스만 남을수밖에 없는데,
이때 자바의 지역변수 캡쳐 기능을 이용해서 지역 변수를 아예 복사해서 지역 클래스 객체에 같이 넣을 수 있다(필드값처럼)
따라서 원본 지역변수가 사라져도 지역변수를 계속 이용할 수 있다.
-> 바깥 클래스의 메서드 안에 속한 지역 클래스가 있을때 그 지역 클래스가 속한 메서드의 변수들은 모두 지역 변수여서(매개변수 포함) 스택에 메서드랑 같이 쌓이다가 종료되고
지역 클래스는 힙 영역에 들어갔다가 나중에 사라져서 지역변수보다 생명주기가 김  

- 지역 클래스가 접근하는 지역 변수는 불변이어야 한다
따라서 final로 선언하거나 사실상 final이어야 한다

사실상 final이라는 뜻은 지역변수를 초기화하고 값을 한번도 변경하지 않은 것을 의미한다

지역변수 값을 변경하면 복사한 값과 원본 값이 서로 달라질수 있어서 문제가 생기고 이 외에도 많은 문제가 생겨서 못 변경하게 막는것


익명 클래스: 이름이 없는 지역 클래스
-> new 다음에 바로 상속받아 구현할 부모 클래스 타입을 입력하고 그 밑에 클래스 정의부를 바로 씀
-> 부모 클래스의 인터페이스를 실제로 구현하는데, 이름은 없는 클래스


익명 클래스 특징
1. 이름 없는 지역 클래스를 선언한 동시에 생성됨
2. 반드시 부모 클래스를 상속받거나 인터페이스를 구현해야함. 즉 익명 클래스를 생성할 때는 상속받을 부모 클래스나 구현할 인터페이스가 필요함
3. 익명 클래스는 이름 자체가 없으므로 생성자도 없음(기본 생성자만 사용)
4. AnonymousOuter$1처럼 바깥 클래스 이름 + $ + 숫자로 정의됨. 익명 클래스가 여러 개면 $1, $2, $3 으로 숫자가 익명 클래스의 개수만큼 늘어나면서 익명 클래스들을 구분할 수 있게 됨

익명 클래스는 클래스 당 단 하나의 객체만 만드는게 가급적 좋음
-> 객체 하나 더 만들려면 다시 정의부를 쓰고 정의해야함(익명 클래스는 이름이 없으므로 객체를 만들때마다 일일히 정의부를 붙여서 만들어줘야함) 
이는 익명 클래스로 여러 객체를 만드는것이 불편함을 의미함
부모 클래스나 인터페이스의 이름으로 객체를 여러 개 만들거라면 익명 대신 지역 클래스로 선언해야함

사용처: 지역 클래스가 일회용으로만 쓰이거나 간단한 구현할때 씀


지역 클래스 이용한 리펙토링:
- 변하지 않는 부분과 변하는 부분을 따로 분리하기
- 타입에 따라 변하는 부분을 각각 다른 지역 클래스로 선언해서 main 메서드에 넣기 
- 과정을 실제로 수행하는 메서드를 가진 인터페이스를 하나 만든후 그 메서드(정의만함)가 지역 클래스 객체를 매개변수로 받도록 설정하기
-> 어떤 타입의 객체가 오는지에 따라 다른 내용의 메서드가 호출됨(오버라이딩 구현)

-> 클래스 타입에 따라 오버라이딩 내용이 다른 것과 익명 클래스에서 여러 객체를 만들려면 정의를 일일히 새로 해야 한다는 점을 이용: 익명 클래스에서 객체를 만들때마다, 인터페이스의 메서드를 오버라이딩하여 구현한 내용을 새로 정의해주기

-> 익명 클래스 객체를 만들때 변수 이름을 만들어서 객체 참조값을 복사해주는 대신, 객체 자체를 메서드 인수로 바로 전달할 수 있음
이때 인수로 익명 클래스 객체가 들어가고, 익명 클래스 객체는 생성할때마다 정의부를 써줘야 하므로, 메서드의 인수로 익명 클래스 객체가 들어간 다음 그 객체의 정의부도 같이 메서드의 괄호() 안에 들어가게 됨

기존엔 메서드 인자로 기본형이나 참조형만 전달할 수 있었음
-> 람다: 메서드 인자로 또 다른 메서드를 통째로 전달할 수 있게 해주는 것

형식: 매개변수 -> {실행문}
어떤 메서드에 전달할 매개변수가 없고 ()만 있다면, 람다식에서도 매개변수 자리에 ()만 넣을 수 있음(어차피 매개변수 전달할 메서드가 매개변수 안받으니까 상관없음)


예외 클래스 선언: 새로운 클래스를 만들고 그 클래스가 Exception 클래스를 상속받게 하면 그 클래스는 예외 클래스가 됨
-> Exception 받으면 체크 예외가 됨
-> RuntimeException 상속받으면 언체크 예외 됨

throw: 새로운 예외 생성
throw도 객체이므로 new 로 객체 생성후 예외 발생시켜야 함

throws: 발생시킨 예외를 메서드 밖으로 내보낼때 사용하는 키워드
-> throw, throws 헷갈리지 말것


try ~ catch()문: try에서 예외를 잡아 catch 로 넘김
만약 try에서 잡은 예외가 catch 의 대상에 없으면 try가 예외를 잡을 수 없음 이때는 예외를 밖으로 내보내야 함

catch에 예외를 지정하면 해당 예외와 그 하위 예외를 모두 잡아줌

예외도 객체여서 다형성이 적용됨

체크 예외 정리: 현재 메서드에서 잡아서 처리하거나, 처리못하면 자기 호출한 메서드로 보내기
잡는것은 try ~ catch()로 잡아서 처리하고
내보내는것은 throws를 지정해서 예외를 내보냄

예외 장점
- 컴파일러에서 예외를 잡아서 알려주는 안전장치 느낌(안전성 높음)
단점
- 개발자가 모든 예외를 체크해서 처리해야 하므로 번거로움(귀찮음)

언체크 예외: RuntimeException - 컴파일러가 예외를 체크하지 않음
예외를 던지는 throws를 선언하지 않고 생략 가능함
생략하면 자동으로 예외를 던짐

체크 예외: 예외를 잡아서 처리하지 않으면(즉 예외를 던질거라면) 항상 throws 키워드를 사용해서 던지는 예외를 직접 선언해야 한다.
언체크 예외: 예외를 잡아서 처리하지 않아도 throws 키워드를 생략할 수 있다(자동으로 예외 던져줌)
물론 필요한 경우 예외를 잡아서 처리 가능함

언체크 예외 장점
- 사소한 예외는 무시 가능함(어차피 알아서 버리므로)
단점
- 개발자가 실수로 중요한 예외를 누락할 수 있는 가능성이 있음


다시 정리

체크 예외: Exception 사용, 예외를 잡아서 직접 처리하거나 처리 못하면 자신을 호출한 메서드로 예외를 보내거나 둘중 하나임
예외를 보낼때는 예외에 throws(throw와 헷갈리지 말것. throw는 새로운 예외를 생성하는 키워드임) 키워드를 선언해서 보내고, 예외를 잡을때는 try ~ catch()문을 통해 catch에 지정한 기준에 적합한 예외를 잡아서 처리함

사용자가 예외를 명시적으로 처리해줘야 해서 번거롭지만, 예외에 대한 메세지를 컴파일러에서 알려주기 때문에 안전성은 높음

언체크 예외: RuntimeException 사용, 
예외를 잡아도 되고 안잡아도 되고 
예외를 자신을 호출한 메서드에 명시적으로 보내지 않아도 됨(컴파일러에서 자동으로 보내줌)
내보낼때도 예외에 throws 안붙여주고 생략해도 됨

사소한 예외는 생략할 수 있어서 비교적 편하고 자유도가 높지만
사용자가 실수로 중요한 예외를 누락할 수 있어서 사용할거면 제대로 사용해야 함